<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[EventBus3.0源码解析-03]]></title>
    <url>%2F2019%2F01%2F09%2FEventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-03%2F</url>
    <content type="text"><![CDATA[EventBus3.0源码解析-02中我们介绍到，当用户调用EventBus的register方法时，会收集保存相应的订阅信息。而在收集订阅信息的过程中，有两种方式，一种通过反射收集，一种通过注解处理器在编译期生成的索引文件进行收集。第一种方式已经在EventBus3.0源码解析-02中进行了详细的介绍，本文将介绍通过索引文件的方式。 注解处理器如果读者对注解处理器还不是很了解，可以阅读这篇文章进行学习。本文我假设大家对注解处理器已经有了基本的了解，将主要介绍EventBus3.0的注解处理器逻辑。其主要实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) &#123; Messager messager = processingEnv.getMessager(); try &#123; String index = processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX); if (index == null) &#123; messager.printMessage(Diagnostic.Kind.ERROR, &quot;No option &quot; + OPTION_EVENT_BUS_INDEX + &quot; passed to annotation processor&quot;); return false; &#125; verbose = Boolean.parseBoolean(processingEnv.getOptions().get(OPTION_VERBOSE)); int lastPeriod = index.lastIndexOf(&apos;.&apos;); String indexPackage = lastPeriod != -1 ? index.substring(0, lastPeriod) : null; round++; if (verbose) &#123; messager.printMessage(Diagnostic.Kind.NOTE, &quot;Processing round &quot; + round + &quot;, new annotations: &quot; + !annotations.isEmpty() + &quot;, processingOver: &quot; + env.processingOver()); &#125; if (env.processingOver()) &#123; if (!annotations.isEmpty()) &#123; messager.printMessage(Diagnostic.Kind.ERROR, &quot;Unexpected processing state: annotations still available after processing over&quot;); return false; &#125; &#125; if (annotations.isEmpty()) &#123; return false; &#125; if (writerRoundDone) &#123; messager.printMessage(Diagnostic.Kind.ERROR, &quot;Unexpected processing state: annotations still available after writing.&quot;); &#125; collectSubscribers(annotations, env, messager); checkForSubscribersToSkip(messager, indexPackage); if (!methodsByClass.isEmpty()) &#123; createInfoIndexFile(index); &#125; else &#123; messager.printMessage(Diagnostic.Kind.WARNING, &quot;No @Subscribe annotations found&quot;); &#125; writerRoundDone = true; &#125; catch (RuntimeException e) &#123; // IntelliJ does not handle exceptions nicely, so log and print a message e.printStackTrace(); messager.printMessage(Diagnostic.Kind.ERROR, &quot;Unexpected error in EventBusAnnotationProcessor: &quot; + e); &#125; return true;&#125; 通过上面代码我们知道，其核心逻辑应该在collectSubscribers，checkForSubscribersToSkip和createInfoIndexFile三个方法中。 注意这句代码String index = processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX)，OPTION_EVENT_BUS_INDEX的值为“eventBusIndex”，它将获取注解处理器的可选参数，是由用户指定的，那么怎么指定呢？ 1、由@SupportedOptions指定注解处理器可以接收哪些可选参数： 2、在app工程的build.gradle文件中传入参数值： 后面我们接着介绍collectSubscribers，checkForSubscribersToSkip和createInfoIndexFile三个方法。 collectSubscribers方法collectSubscribers方法的实现如下： 123456789101112131415161718192021private void collectSubscribers(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env, Messager messager) &#123; for (TypeElement annotation : annotations) &#123; // 找到所有有annotation注解的元素信息 Set&lt;? extends Element&gt; elements = env.getElementsAnnotatedWith(annotation); for (Element element : elements) &#123; // 元素是否是可执行元素，比如方法 if (element instanceof ExecutableElement) &#123; ExecutableElement method = (ExecutableElement) element; // 检查方法定义是否符合规范 if (checkHasNoErrors(method, messager)) &#123; // 方法所在的类元素 TypeElement classElement = (TypeElement) method.getEnclosingElement(); // 保存找到的元素 methodsByClass.putElement(classElement, method); &#125; &#125; else &#123; messager.printMessage(Diagnostic.Kind.ERROR, &quot;@Subscribe is only valid for methods&quot;, element); &#125; &#125; &#125;&#125; collectSubscribers方法逻辑相对简单，相信读者通过阅读代码注释就能明白，就是把所有有用的信息收集到了methodsByClass变量中。其中，checkHasNoErrors方法的实现如下： 123456789101112131415161718192021private boolean checkHasNoErrors(ExecutableElement element, Messager messager) &#123; // 方法修饰符是否包含static if (element.getModifiers().contains(Modifier.STATIC)) &#123; messager.printMessage(Diagnostic.Kind.ERROR, &quot;Subscriber method must not be static&quot;, element); return false; &#125; // 方法修饰符是否包含public if (!element.getModifiers().contains(Modifier.PUBLIC)) &#123; messager.printMessage(Diagnostic.Kind.ERROR, &quot;Subscriber method must be public&quot;, element); return false; &#125; List&lt;? extends VariableElement&gt; parameters = ((ExecutableElement) element).getParameters(); // 方法是否只有一个参数 if (parameters.size() != 1) &#123; messager.printMessage(Diagnostic.Kind.ERROR, &quot;Subscriber method must have exactly 1 parameter&quot;, element); return false; &#125; return true;&#125; checkForSubscribersToSkipcheckForSubscribersToSkip方法的实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private void checkForSubscribersToSkip(Messager messager, String myPackage) &#123; for (TypeElement skipCandidate : methodsByClass.keySet()) &#123; TypeElement subscriberClass = skipCandidate; while (subscriberClass != null) &#123; // subscriberClass类在myPackage包名下面是否可见 if (!isVisible(myPackage, subscriberClass)) &#123; boolean added = classesToSkip.add(skipCandidate); if (added) &#123; String msg; if (subscriberClass.equals(skipCandidate)) &#123; msg = &quot;Falling back to reflection because class is not public&quot;; &#125; else &#123; msg = &quot;Falling back to reflection because &quot; + skipCandidate + &quot; has a non-public super class&quot;; &#125; messager.printMessage(Diagnostic.Kind.NOTE, msg, subscriberClass); &#125; break; &#125; List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberClass); if (methods != null) &#123; for (ExecutableElement method : methods) &#123; String skipReason = null; VariableElement param = method.getParameters().get(0); TypeMirror typeMirror = getParamTypeMirror(param, messager); if (!(typeMirror instanceof DeclaredType) || !(((DeclaredType) typeMirror).asElement() instanceof TypeElement)) &#123; skipReason = &quot;event type cannot be processed&quot;; &#125; if (skipReason == null) &#123; TypeElement eventTypeElement = (TypeElement) ((DeclaredType) typeMirror).asElement(); // eventTypeElement事件类在myPackage包名下面是否可见 if (!isVisible(myPackage, eventTypeElement)) &#123; skipReason = &quot;event type is not public&quot;; &#125; &#125; if (skipReason != null) &#123; boolean added = classesToSkip.add(skipCandidate); if (added) &#123; String msg = &quot;Falling back to reflection because &quot; + skipReason; if (!subscriberClass.equals(skipCandidate)) &#123; msg += &quot; (found in super class for &quot; + skipCandidate + &quot;)&quot;; &#125; messager.printMessage(Diagnostic.Kind.NOTE, msg, param); &#125; break; &#125; &#125; &#125; subscriberClass = getSuperclass(subscriberClass); &#125; &#125;&#125; checkForSubscribersToSkip方法的逻辑是，因为我们将在myPackage包名下面创建索引文件，而如果某些订阅类或者父类在myPackage包名下面是不可见的，那么这些类不应该创建相应的索引代码。同样的，如果订阅方法的事件参数类在myPackage包名下面是不可见的，那么这些类也不应该创建相应的索引代码。 createInfoIndexFilecreateInfoIndexFile方法就是按照一定规则自动生成java代码，创建相应java源文件。下面通过一个具体的例子来说明createInfoIndexFile方法会生成什么样的文件。 1、在OtherClass类中使用@Subscribe声明了一个订阅方法： 1234567public class OtherClass &#123; @Subscribe() public void test(String str)&#123; Log.d(&quot;eventbusTest&quot;, &quot;OtherClass&quot;); &#125;&#125; 2、在MainActivity类中使用@Subscribe声明了一个订阅方法： 123456public class MainActivity extends AppCompatActivity &#123; @Subscribe() public void test(String str)&#123; Log.d(&quot;eventbusTest&quot;, &quot;MainActivity&quot;); &#125;&#125; 3、点击build，会在你通过eventBusIndex指定的路径下面生成一个索引文件，本文指定是”com.yong.cugyong.eventbus_sample.MyEventBusIndex“： MyEventBusIndex文件的内容如下： 12345678910111213141516171819202122232425262728293031/** This class is generated by EventBus, do not edit. */public class MyEventBusIndex implements SubscriberInfoIndex &#123; private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX; static &#123; SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;(); putIndex(new SimpleSubscriberInfo(MainActivity.class, true, new SubscriberMethodInfo[] &#123; new SubscriberMethodInfo(&quot;test&quot;, String.class), &#125;)); putIndex(new SimpleSubscriberInfo(OtherClass.class, true, new SubscriberMethodInfo[] &#123; new SubscriberMethodInfo(&quot;test&quot;, String.class), &#125;)); &#125; private static void putIndex(SubscriberInfo info) &#123; SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info); &#125; @Override public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123; SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass); if (info != null) &#123; return info; &#125; else &#123; return null; &#125; &#125;&#125; 这里大家只要知道编译工程之后会生成这样一个文件，在下一部分将告诉大家具体含义。 索引文件使用在文章开头我们介绍到，用户调用EventBus的register方法时，会收集保存相应的订阅信息，而这里我们就介绍怎么通过索引文件找到想要的信息，对register逻辑还不是很了解的朋友可以先看一下EventBus3.0源码解析-02。 通过索引文件收集信息的入口函数是SubscriberMethodFinder类的findUsingInfo方法，该方法的实现如下： 1234567891011121314151617181920private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; // 索引文件中未找到，则使用反射 findUsingReflectionInSingleClass(findState); &#125; findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState);&#125; 该方法里面的大多数逻辑我们都在EventBus3.0源码解析-02中进行了介绍，这里我们只介绍不同点getSubscriberInfo方法，其实现如下： 1234567891011121314151617181920private SubscriberInfo getSubscriberInfo(FindState findState) &#123; // 如果需要找的信息已经存在，直接返回 if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) &#123; SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo(); if (findState.clazz == superclassInfo.getSubscriberClass()) &#123; return superclassInfo; &#125; &#125; // 通常会直接走这一块逻辑 if (subscriberInfoIndexes != null) &#123; // 遍历所有索引文件 for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123; SubscriberInfo info = index.getSubscriberInfo(findState.clazz); if (info != null) &#123; return info; &#125; &#125; &#125; return null;&#125; 该方法遍历所有索引文件，调用索引文件中getSubscriberInfo方法根据订阅类寻找订阅信息。因为这种寻找订阅信息的方式没有反射，所以效率很高。 总结EventBus通过索引文件寻找订阅信息，是通过在编译期通过注解处理器生成相应的索引文件，然后在运行期使用索引文件寻找订阅信息，这样在运行期就不需要使用到反射了，提高了效率。]]></content>
      <categories>
        <category>EventBus3.0</category>
      </categories>
      <tags>
        <tag>EventBus3.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus3.0源码解析-02]]></title>
    <url>%2F2019%2F01%2F08%2FEventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02%2F</url>
    <content type="text"><![CDATA[EventBus3.0源码解析-01这篇文章简单的介绍了EventBus的使用流程，我们知道EventBus有三个主要入口方法，分别为 1EventBus.getDefault().register(Object); 1EventBus.getDefault().unregister(Object); 1EventBus.getDefault().post(Object); 本文将通过register入口方法及其逻辑，分析EventBus源码。 EventBus的register方法实现如下： 123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125;&#125; register函数主要实现了两个功能，1、将订阅类中所有订阅方法收集；2、按一定规则保存收集的信息。 订阅方法收集订阅方法收集主要由SubscriberMethodFinder类的findSubscriberMethods函数实现，我们看下其具体实现： 123456789101112131415161718192021List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; // 先从缓存中获取，即之前该类是否注册使用过 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; // 是否忽略注解处理器生成的索引文件 if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); &#125; else &#123; METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125;&#125; 1、如果参数中的subscriberClass类之前注册过，那么直接从METHOD_CACHE缓存中获取信息返回。 2、根据ignoreGeneratedIndex判断是否要根据注解处理器在编译期生成的索引文件来寻找订阅方法信息，该方式是从EventBus3.0中引入的，目的是为了提高EventBus的整体效率。如果ignoreGeneratedIndex为true，则使用反射来寻找订阅方法信息，否则，先根据生成的索引文件来寻找订阅方法信息，索引文件中找不到，再使用反射寻找。 3、如果找到的订阅方法信息非空，则将这些信息缓存在METHOD_CACHE中。 第1、3步没有什么好讲的内容，主要的内容在第2步。由于根据索引文件寻找订阅方法信息的方式还涉及注解处理器，稍微复杂，所以会单独开一篇文章讲这块。本文主要介绍通过反射来寻找订阅方法信息的方式。 我们来看一下findUsingReflection的具体实现： 12345678910private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123; FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); // 遍历订阅类以及其父类 while (findState.clazz != null) &#123; findUsingReflectionInSingleClass(findState); findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState);&#125; 123456789101112private FindState prepareFindState() &#123; synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; FindState state = FIND_STATE_POOL[i]; if (state != null) &#123; FIND_STATE_POOL[i] = null; return state; &#125; &#125; &#125; return new FindState();&#125; prepareFindState()方法会尝试从缓存中寻找是否有现存的FindState对象，如果有，则直接使用缓存的FindState对象，否则，直接new一个FindState对象。 1234567void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123; // 保存订阅类信息 this.subscriberClass = clazz = subscriberClass; // 是否忽略父类 skipSuperClasses = false; subscriberInfo = null;&#125; initForSubscriber方法就是简单的初始化了一些参数。 接下来我们看下核心方法findUsingReflectionInSingleClass的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // getDeclaredMethods()方法的效率要优于getMethods() methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123; // 获取方法的修饰符, 比如public, static等修饰符 int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; // 获取方法的参数信息 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); // 方法只有一个参数 if (parameterTypes.length == 1) &#123; // 获取方法的@Subscribe注解信息 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); // 如果方法有@Subscribe注解信息 if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; // 检查当前method是否是有效的订阅方法 if (findState.checkAdd(method, eventType)) &#123; // 如果当前method是有效的订阅方法，则把该订阅方法收集起来 ThreadMode threadMode = subscribeAnnotation.threadMode(); findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;); &#125; &#125;&#125; findUsingReflectionInSingleClass方法加了详细的注解，大多数逻辑都能直接看代码注释弄明白。这里主要要介绍的是findState.checkAdd(method, eventType)方法，checkAdd的实现如下： 123456789101112131415161718boolean checkAdd(Method method, Class&lt;?&gt; eventType) &#123; // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required. // Usually a subscriber doesn&apos;t have methods listening to the same event type. Object existing = anyMethodByEventType.put(eventType, method); if (existing == null) &#123; return true; &#125; else &#123; if (existing instanceof Method) &#123; if (!checkAddWithMethodSignature((Method) existing, eventType)) &#123; // Paranoia check throw new IllegalStateException(); &#125; // Put any non-Method object to &quot;consume&quot; the existing Method anyMethodByEventType.put(eventType, this); &#125; return checkAddWithMethodSignature(method, eventType); &#125;&#125; 考虑到同一个类里面通常只会有一个方法监听同一类事件，为了效率，所以EventBus先根据事件类型去匹配同一个类中是否已经有添加过的方法监听同一类事件，如果没有，则直接认为该方法为有效订阅方法，如果之前已经添加过方法监听同一类事件，则通过checkAddWithMethodSignature来判断该方法是否为有效订阅方法。checkAddWithMethodSignature的实现如下： 123456789101112131415161718private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123; methodKeyBuilder.setLength(0); methodKeyBuilder.append(method.getName()); methodKeyBuilder.append(&apos;&gt;&apos;).append(eventType.getName()); String methodKey = methodKeyBuilder.toString(); Class&lt;?&gt; methodClass = method.getDeclaringClass(); Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass); // methodClassOld 是否是 methodClass的父类或者接口 if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123; // Only add if not already found in a sub class return true; &#125; else &#123; // Revert the put, old class is further down the class hierarchy subscriberClassByMethodKey.put(methodKey, methodClassOld); return false; &#125;&#125; 根据一定规则计算出方法的唯一特征名称，如果具有该特征名称的方法之前还没有添加过，则认为当前方法为有效订阅方法。否则，如果之前添加过的方法所在的类是当前方法所在类的父类或者接口，考虑到子类重写，认为当前方法为有效订阅方法。否则认为当前方法为非有效订阅方法。 通过上面的多次调用findUsingReflectionInSingleClass方法，我们已经把有效的订阅信息收集到了findState的subscriberMethods变量中。 保存所有订阅信息我们再回到findUsingReflection方法，接着会调用getMethodsAndRelease(findState)方法，我们看看它的实现： 12345678910111213private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123; List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods); findState.recycle(); synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; if (FIND_STATE_POOL[i] == null) &#123; FIND_STATE_POOL[i] = findState; break; &#125; &#125; &#125; return subscriberMethods;&#125; 它其实做的事情就是把findState放入到缓存中，然后返回刚刚收集到的有效订阅信息。 现在我们回到register方法，我们收集到了有效的订阅信息List，接着会循环调用subscribe(subscriber, subscriberMethod)方法，我们看看这个方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Must be called in synchronized blockprivate void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; Class&lt;?&gt; eventType = subscriberMethod.eventType; Subscription newSubscription = new Subscription(subscriber, subscriberMethod); CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); &#125; &#125; // 优先级高的放列表的前面 int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); if (subscriberMethod.sticky) &#123; // 是否考虑注册方法的参数，事件的继承关系 if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125;&#125; 这个函数的代码虽然很长，但是其只做了三件事情，1、将订阅信息以事件类型为key保存在subscriptionsByEventType变量中（方便post方法调用的时候，以事件为key寻找订阅信息）；2、将事件类型以订阅类为key保存在typesBySubscriber变量中（方便unregister方法调用的时候，以订阅类为key寻找事件类型，然后根据subscriptionsByEventType变量找到订阅信息）；3、处理sticky事件逻辑。关于第3点，考虑到本文篇幅，我将另外开一篇文章进行分析。 总结所以通过调用register方法，最终订阅方法信息会被最终保存在subscriptionsByEventType变量和typesBySubscriber变量中。 如果你喜欢，感谢给个赞。如果有什么问题，欢迎评论。]]></content>
      <categories>
        <category>EventBus3.0</category>
      </categories>
      <tags>
        <tag>EventBus3.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus3.0源码解析-01]]></title>
    <url>%2F2019%2F01%2F08%2FEventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01%2F</url>
    <content type="text"><![CDATA[最近在学习EventBus源码，本着学习完之后要及时总结，方便以后回顾的心态，这里做一个系列来分析EventBus的源码。本系列讨论的都是最新的EventBus3.0的源码。EventBus GitHub地址 EventBus在gradle工程中引入的方式如下： 1implementation &apos;org.greenrobot:eventbus:3.1.1&apos; EventBus的基本流程 从官网流程图可以看出，EventBus使用的是观察者模式，Publisher(发布者)调用post方法将事件发送给订阅了该事件的Subscriber(订阅者)。 Publisher(发布者)—调用post方法发布事件的类就是发布者 Subscriber(订阅者)—通过@Subscribe注解的方法就是订阅者 EventBus—负责把post方法发布的事件通知给相应的订阅者 EventBus的基本使用逻辑如下： 定义事件类型 1public static class MessageEvent &#123; /* Additional fields if needed */ &#125; 通过@Subscriber准备订阅方法 12@Subscribe(threadMode = ThreadMode.MAIN) public void onMessageEvent(MessageEvent event) &#123;/* Do something */&#125;; 其中@Subscriber可以指定三个参数： ThreadMode—指定订阅方法(上文中的onMessageEvent方法)运行在什么线程，默认是POSTING； POSTING：表示订阅方法运行在当前发布事件的线程(调用post方法的线程)； MAIN：表示订阅方法运行在UI线程。如果当前发布事件的线程是UI线程，则订阅方法直接运行，否则，事件入队列等待触发订阅方法(入队列的方式不阻塞线程)； MAIN_ORDERED：表示订阅方法运行在UI线程。它和MAIN的区别是，事件会直接入队列等待触发订阅方法； BACKGROUND：表示订阅方法运行在后台线程。如果当前发布事件的线程是后台线程，则订阅方法直接运行，否则，订阅方法将会运行在一个唯一的后台线程中，该唯一的后台线程将会负责运行所有有BACKGROUND标识的订阅方法； ASYNC：表示订阅方法将总是运行在一个新的后台线程，即即使当前发布事件的线程是后台线程，它也会运行在一个新的后台线程。 priority—表示该方法的优先级，默认是0。当发布事件的时候，同一线程中，优先级值越大的方法，会被更早调用； sticky—如果为true，将会发送最新的sticky事件给相应的订阅者，默认为false； sticky的使用一般为：如果用户希望先调用postSticky发布事件，再注册订阅者接收该事件，则可以指定sticky为true。 注册和取消注册包含订阅方法的订阅者 比如在Activity中，方式一般如下： 123456789101112131415@Override public void onStart() &#123; super.onStart(); EventBus.getDefault().register(this); &#125; @Override public void onStop() &#123; super.onStop(); EventBus.getDefault().unregister(this); &#125; // 订阅方法 @Subscribe(threadMode = ThreadMode.MAIN) public void onMessageEvent(MessageEvent event) &#123;/* Do something */&#125;; 发布事件 1EventBus.getDefault().post(new MessageEvent()); 通过上文，我们知道eventbus的基本使用流程主要有四个步骤，而其中涉及eventbus的主要有三个方法，分别为register注册订阅者，unregister取消注册，post发布事件。后续我将分别以这三个方法为入口，对eventbus源码进行解析，敬请期待。]]></content>
      <categories>
        <category>EventBus3.0</category>
      </categories>
      <tags>
        <tag>EventBus3.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android开发-常用网址]]></title>
    <url>%2F2019%2F01%2F05%2Fandroid%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E7%BD%91%E5%9D%80%2F</url>
    <content type="text"><![CDATA[android development 网址 https://developer.android.com/guide/]]></content>
  </entry>
  <entry>
    <title><![CDATA[安卓注解处理器-processor]]></title>
    <url>%2F2019%2F01%2F04%2F%E5%AE%89%E5%8D%93%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8-processor%2F</url>
    <content type="text"><![CDATA[最近在学习安卓开源框架发现，很多的开源框架都使用到了注解处理器，例如EventBus3.0。本文通过一个简单的Demo来介绍如何使用注解处理器。Demo链接为https://github.com/cugyong/AnnotationProcessor-sample ，如果喜欢的话，欢迎大家给star。 Demo需求描述用户通过执行一个传入参数为A（类对象）的静态方法，该方法会最终把参数A中加了特定注解的所有方法执行一遍。 需求实现 整个项目分为四个部分： 注解–要使用的注解类型，这部分通常也可以放在lib中； 注解处理器–要对注解进行处理的逻辑，包括收集有特定注解类型的方法信息以及生成特定的java文件； lib–封装合适的接口，供具体调用方调用； sample–具体的调用方逻辑。 首先新建一个安卓工程，点击运行展示的是hello world。 注解在上述工程中new-&gt;Module-&gt;Java Library，新建一个Java Library Module，命名为annotation。在该Module下创建一个文件AnnotationTest.java， AnnotationTest.java里面代码如下： 12345@Retention(RetentionPolicy.CLASS)@Target(ElementType.METHOD)public @interface AnnotationTest &#123; String name() default &quot;test&quot;;&#125; 1、注解@Retention按生命周期来划分可分为3类： RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃； RetentionPolicy.CLASS：注解被保留到class文件，当jvm加载class文件时候被遗弃，这是默认的生命周期； RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在。 这3个生命周期分别对应于：Java源文件(.java文件) —&gt; .class文件 —&gt; 内存中的字节码。 2、注解@Target表示修饰的注解能使用的范围，ElementType.METHOD表示@AnnotationTest注解只能作用在方法上。 注解处理器参照上部分，在工程中new-&gt;Module-&gt;Java Library，新建一个Java Library Module， 在该Module下创建一个文件ProcessorTest.java。在该Module下的build.gradle的dependencies中添加如下配置： 1234// 自动为processor注册implementation &apos;com.google.auto.service:auto-service:1.0-rc2&apos;// 该Module依赖上部分建立的annotation Moduleimplementation project(&apos;:annotation&apos;) com.google.auto.service:auto-service:1.0-rc2依赖的作用是为注解处理器自动注册，它会生成META-INF文件夹。 注解处理器ProcessorTest的定义如下，其中@AutoService(Processor.class)就是build.gradle中加的依赖帮助其自动注册。 12@AutoService(Processor.class) // 自动为ProcessorTest注册，生成META-INF文件public class ProcessorTest extends AbstractProcessor&#123; 注解处理器ProcessorTest主要包含以下几个部分： 1234567@Overridepublic synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); mMessager = processingEnvironment.getMessager(); mFiler = processingEnvironment.getFiler();&#125; init方法是注解处理器会自动调用的初始化方法，其中mFiler是用来生成java源文件的工具，mMessager是用来打印日志的，它们的具体使用会在后面介绍。 123456@Overridepublic Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; supportAnnotationTypes = new HashSet&lt;&gt;(); supportAnnotationTypes.add(AnnotationTest.class.getCanonicalName()); return supportAnnotationTypes;&#125; getSupportedAnnotationTypes()方法返回该注解处理器支持的注解类型，这里返回的就是我们之前声明的新的注解类型@AnnotationTest。 1234@Overridepublic SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported();&#125; getSupportedSourceVersion()方法一般就按照上述实现就行。 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnvironment) &#123; // 打印日志 mMessager.printMessage(Diagnostic.Kind.NOTE, &quot;process start&quot;); Map&lt;String, List&lt;String&gt;&gt; collectInfos = new HashMap&lt;&gt;(); for (TypeElement annotation: annotations)&#123; Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(annotation); for (Element element: elements)&#123; // 检查element是否符合我们定义的规范 if (!checkValid(element))&#123; mMessager.printMessage(Diagnostic.Kind.NOTE, &quot;checkValid not pass&quot;); return false; &#125;else &#123; ExecutableElement executableElement = (ExecutableElement) element; // 获取被注解的方法所在的类 TypeElement typeElement = (TypeElement) executableElement.getEnclosingElement(); // 获取类的全名，包括包名 String classFullName = typeElement.getQualifiedName().toString(); // 被注解的方法的名字 String methodName = executableElement.getSimpleName().toString(); List&lt;String&gt; methods = collectInfos.get(classFullName); if (methods == null)&#123; methods = new ArrayList&lt;&gt;(); collectInfos.put(classFullName, methods); &#125; methods.add(methodName); &#125; &#125; &#125; for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry: collectInfos.entrySet())&#123; mMessager.printMessage(Diagnostic.Kind.NOTE, entry.getKey()); // 生成java源文件 createJavaFile(entry.getKey(), entry.getValue()); &#125; return true;&#125; process方法是我们的主要逻辑处理的地方，主要逻辑就是收集所有有@AnnotationTest注解的方法以及其所在的类信息，然后根据每个类信息，生成一个新的类文件，并在新的类文件的特定方法中调用所有关联的注解方法。生成java源文件将使用Filer对象，具体如何使用请下载demo看源代码。 注： 1、当你点击buid project时，注解处理器将会执行，而Messager对象打印出来的日志信息可以在Gradle Console窗口中看到。 2、如果你在该Module中使用中文注解，因为该Module为java library，可能会报GBK编码错误，解决办法是在该Module的build.gradle中添加如下代码： 1234//指定编译的编码tasks.withType(JavaCompile)&#123; options.encoding = &quot;UTF-8&quot;&#125; Lib在工程中new-&gt;Module-&gt;Android Library ，新建一个Android Library Module，封装接口给调用方使用，具体逻辑请参考demo。 最终该demo的功能是点击Hello world文字，会依此执行MainActivity中使用@AnnotationTest注解的方法。]]></content>
      <categories>
        <category>注解</category>
      </categories>
      <tags>
        <tag>annotation、processor、自动生成java文件</tag>
      </tags>
  </entry>
</search>
