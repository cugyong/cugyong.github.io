<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[EventBus3源码解析-02]]></title>
    <url>%2F2019%2F01%2F08%2FEventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02%2F</url>
    <content type="text"><![CDATA[EventBus3源码解析-01这篇文章简单的介绍了EventBus的使用流程，我们知道EventBus有三个主要入口方法，分别为 1EventBus.getDefault().register(Object); 1EventBus.getDefault().unregister(Object); 1EventBus.getDefault().post(Object); 本文将通过register入口方法及其逻辑，分析EventBus源码。 EventBus的register方法实现如下： 123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125;&#125; register函数主要实现了两个功能，1、将订阅类中所有订阅方法收集；2、按一定规则保存收集的信息。 订阅方法收集订阅方法收集主要由SubscriberMethodFinder类的findSubscriberMethods函数实现，我们看下其具体实现： 123456789101112131415161718192021List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; // 先从缓存中获取，即之前该类是否注册使用过 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; // 是否忽略注解处理器生成的索引文件 if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); &#125; else &#123; METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125;&#125; 1、如果参数中的subscriberClass类之前注册过，那么直接从METHOD_CACHE缓存中获取信息返回。 2、根据ignoreGeneratedIndex判断是否要根据注解处理器在编译期生成的索引文件来寻找订阅方法信息，该方式是从EventBus3.0中引入的，目的是为了提高EventBus的整体效率。如果ignoreGeneratedIndex为true，则使用反射来寻找订阅方法信息，否则，先根据生成的索引文件来寻找订阅方法信息，索引文件中找不到，再使用反射寻找。 3、如果找到的订阅方法信息非空，则将这些信息缓存在METHOD_CACHE中。 第1、3步没有什么好讲的内容，主要的内容在第2步。由于根据索引文件寻找订阅方法信息的方式还涉及注解处理器，稍微复杂，所以会单独开一篇文章讲这块。本文主要介绍通过反射来寻找订阅方法信息的方式。 我们来看一下findUsingReflection的具体实现： 12345678910private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123; FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); // 遍历订阅类以及其父类 while (findState.clazz != null) &#123; findUsingReflectionInSingleClass(findState); findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState);&#125; 123456789101112private FindState prepareFindState() &#123; synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; FindState state = FIND_STATE_POOL[i]; if (state != null) &#123; FIND_STATE_POOL[i] = null; return state; &#125; &#125; &#125; return new FindState();&#125; prepareFindState()方法会尝试从缓存中寻找是否有现存的FindState对象，如果有，则直接使用缓存的FindState对象，否则，直接new一个FindState对象。 1234567void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123; // 保存订阅类信息 this.subscriberClass = clazz = subscriberClass; // 是否忽略父类 skipSuperClasses = false; subscriberInfo = null;&#125; initForSubscriber方法就是简单的初始化了一些参数。 接下来我们看下核心方法findUsingReflectionInSingleClass的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // getDeclaredMethods()方法的效率要优于getMethods() methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123; // 获取方法的修饰符, 比如public, static等修饰符 int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; // 获取方法的参数信息 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); // 方法只有一个参数 if (parameterTypes.length == 1) &#123; // 获取方法的@Subscribe注解信息 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); // 如果方法有@Subscribe注解信息 if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; // 检查当前method是否是有效的订阅方法 if (findState.checkAdd(method, eventType)) &#123; // 如果当前method是有效的订阅方法，则把该订阅方法收集起来 ThreadMode threadMode = subscribeAnnotation.threadMode(); findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;); &#125; &#125;&#125; findUsingReflectionInSingleClass方法加了详细的注解，大多数逻辑都能直接看代码注释弄明白。这里主要要介绍的是findState.checkAdd(method, eventType)方法，checkAdd的实现如下： 123456789101112131415161718boolean checkAdd(Method method, Class&lt;?&gt; eventType) &#123; // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required. // Usually a subscriber doesn&apos;t have methods listening to the same event type. Object existing = anyMethodByEventType.put(eventType, method); if (existing == null) &#123; return true; &#125; else &#123; if (existing instanceof Method) &#123; if (!checkAddWithMethodSignature((Method) existing, eventType)) &#123; // Paranoia check throw new IllegalStateException(); &#125; // Put any non-Method object to &quot;consume&quot; the existing Method anyMethodByEventType.put(eventType, this); &#125; return checkAddWithMethodSignature(method, eventType); &#125;&#125; 考虑到同一个类里面通常只会有一个方法监听同一类事件，为了效率，所以EventBus先根据事件类型去匹配同一个类中是否已经有添加过的方法监听同一类事件，如果没有，则直接认为该方法为有效订阅方法，如果之前已经添加过方法监听同一类事件，则通过checkAddWithMethodSignature来判断该方法是否为有效订阅方法。checkAddWithMethodSignature的实现如下： 123456789101112131415161718private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123; methodKeyBuilder.setLength(0); methodKeyBuilder.append(method.getName()); methodKeyBuilder.append(&apos;&gt;&apos;).append(eventType.getName()); String methodKey = methodKeyBuilder.toString(); Class&lt;?&gt; methodClass = method.getDeclaringClass(); Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass); // methodClassOld 是否是 methodClass的父类或者接口 if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123; // Only add if not already found in a sub class return true; &#125; else &#123; // Revert the put, old class is further down the class hierarchy subscriberClassByMethodKey.put(methodKey, methodClassOld); return false; &#125;&#125; 根据一定规则计算出方法的唯一特征名称，如果具有该特征名称的方法之前还没有添加过，则认为当前方法为有效订阅方法。否则，如果之前添加过的方法所在的类是当前方法所在类的父类或者接口，考虑到子类重写，认为当前方法为有效订阅方法。否则认为当前方法为非有效订阅方法。 通过上面的多次调用findUsingReflectionInSingleClass方法，我们已经把有效的订阅信息收集到了findState的subscriberMethods变量中。 保存所有订阅信息我们再回到findUsingReflection方法，接着会调用getMethodsAndRelease(findState)方法，我们看看它的实现： 12345678910111213private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123; List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods); findState.recycle(); synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; if (FIND_STATE_POOL[i] == null) &#123; FIND_STATE_POOL[i] = findState; break; &#125; &#125; &#125; return subscriberMethods;&#125; 它其实做的事情就是把findState放入到缓存中，然后返回刚刚收集到的有效订阅信息。 现在我们回到register方法，我们收集到了有效的订阅信息List，接着会循环调用subscribe(subscriber, subscriberMethod)方法，我们看看这个方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Must be called in synchronized blockprivate void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; Class&lt;?&gt; eventType = subscriberMethod.eventType; Subscription newSubscription = new Subscription(subscriber, subscriberMethod); CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); &#125; &#125; // 优先级高的放列表的前面 int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); if (subscriberMethod.sticky) &#123; // 是否考虑注册方法的参数，事件的继承关系 if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125;&#125; 这个函数的代码虽然很长，但是其只做了三件事情，1、将订阅信息以事件类型为key保存在subscriptionsByEventType变量中（方便post方法调用的时候，以事件为key寻找订阅信息）；2、将事件类型以订阅类为key保存在typesBySubscriber变量中（方便unregister方法调用的时候，以订阅类为key寻找事件类型，然后根据subscriptionsByEventType变量找到订阅信息）；3、处理sticky事件逻辑。关于第3点，考虑到本文篇幅，我将另外开一篇文章进行分析。 总结所以通过调用register方法，最终订阅方法信息会被最终保存在subscriptionsByEventType变量和typesBySubscriber变量中。 如果你喜欢，感谢给个赞。如果有什么问题，欢迎评论。]]></content>
      <categories>
        <category>EventBus3.0</category>
      </categories>
      <tags>
        <tag>EventBus3.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus3.0源码解析-01]]></title>
    <url>%2F2019%2F01%2F08%2FEventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01%2F</url>
    <content type="text"><![CDATA[最近在学习EventBus源码，本着学习完之后要及时总结，方便以后回顾的心态，这里做一个系列来分析EventBus的源码。本系列讨论的都是最新的EventBus3.0的源码。EventBus GitHub地址 EventBus在gradle工程中引入的方式如下： 1implementation &apos;org.greenrobot:eventbus:3.1.1&apos; EventBus的基本流程 从官网流程图可以看出，EventBus使用的是观察者模式，Publisher(发布者)调用post方法将事件发送给订阅了该事件的Subscriber(订阅者)。 Publisher(发布者)—调用post方法发布事件的类就是发布者 Subscriber(订阅者)—通过@Subscribe注解的方法就是订阅者 EventBus—负责把post方法发布的事件通知给相应的订阅者 EventBus的基本使用逻辑如下： 定义事件类型 1public static class MessageEvent &#123; /* Additional fields if needed */ &#125; 通过@Subscriber准备订阅方法 12@Subscribe(threadMode = ThreadMode.MAIN) public void onMessageEvent(MessageEvent event) &#123;/* Do something */&#125;; 其中@Subscriber可以指定三个参数： ThreadMode—指定订阅方法(上文中的onMessageEvent方法)运行在什么线程，默认是POSTING； POSTING：表示订阅方法运行在当前发布事件的线程(调用post方法的线程)； MAIN：表示订阅方法运行在UI线程。如果当前发布事件的线程是UI线程，则订阅方法直接运行，否则，事件入队列等待触发订阅方法(入队列的方式不阻塞线程)； MAIN_ORDERED：表示订阅方法运行在UI线程。它和MAIN的区别是，事件会直接入队列等待触发订阅方法； BACKGROUND：表示订阅方法运行在后台线程。如果当前发布事件的线程是后台线程，则订阅方法直接运行，否则，订阅方法将会运行在一个唯一的后台线程中，该唯一的后台线程将会负责运行所有有BACKGROUND标识的订阅方法； ASYNC：表示订阅方法将总是运行在一个新的后台线程，即即使当前发布事件的线程是后台线程，它也会运行在一个新的后台线程。 priority—表示该方法的优先级，默认是0。当发布事件的时候，同一线程中，优先级值越大的方法，会被更早调用； sticky—如果为true，将会发送最新的sticky事件给相应的订阅者，默认为false； sticky的使用一般为：如果用户希望先调用postSticky发布事件，再注册订阅者接收该事件，则可以指定sticky为true。 注册和取消注册包含订阅方法的订阅者 比如在Activity中，方式一般如下： 123456789101112131415@Override public void onStart() &#123; super.onStart(); EventBus.getDefault().register(this); &#125; @Override public void onStop() &#123; super.onStop(); EventBus.getDefault().unregister(this); &#125; // 订阅方法 @Subscribe(threadMode = ThreadMode.MAIN) public void onMessageEvent(MessageEvent event) &#123;/* Do something */&#125;; 发布事件 1EventBus.getDefault().post(new MessageEvent()); 通过上文，我们知道eventbus的基本使用流程主要有四个步骤，而其中涉及eventbus的主要有三个方法，分别为register注册订阅者，unregister取消注册，post发布事件。后续我将分别以这三个方法为入口，对eventbus源码进行解析，敬请期待。]]></content>
      <categories>
        <category>EventBus3.0</category>
      </categories>
      <tags>
        <tag>EventBus3.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android开发-常用网址]]></title>
    <url>%2F2019%2F01%2F05%2Fandroid%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E7%BD%91%E5%9D%80%2F</url>
    <content type="text"><![CDATA[android development 网址 https://developer.android.com/guide/]]></content>
  </entry>
  <entry>
    <title><![CDATA[安卓注解处理器-processor]]></title>
    <url>%2F2019%2F01%2F04%2F%E5%AE%89%E5%8D%93%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8-processor%2F</url>
    <content type="text"><![CDATA[最近在学习安卓开源框架发现，很多的开源框架都使用到了注解处理器，例如EventBus3.0。本文通过一个简单的Demo来介绍如何使用注解处理器。Demo链接为https://github.com/cugyong/AnnotationProcessor-sample ，如果喜欢的话，欢迎大家给star。 Demo需求描述用户通过执行一个传入参数为A（类对象）的静态方法，该方法会最终把参数A中加了特定注解的所有方法执行一遍。 需求实现 整个项目分为四个部分： 注解–要使用的注解类型，这部分通常也可以放在lib中； 注解处理器–要对注解进行处理的逻辑，包括收集有特定注解类型的方法信息以及生成特定的java文件； lib–封装合适的接口，供具体调用方调用； sample–具体的调用方逻辑。 首先新建一个安卓工程，点击运行展示的是hello world。 注解在上述工程中new-&gt;Module-&gt;Java Library，新建一个Java Library Module，命名为annotation。在该Module下创建一个文件AnnotationTest.java， AnnotationTest.java里面代码如下： 12345@Retention(RetentionPolicy.CLASS)@Target(ElementType.METHOD)public @interface AnnotationTest &#123; String name() default &quot;test&quot;;&#125; 1、注解@Retention按生命周期来划分可分为3类： RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃； RetentionPolicy.CLASS：注解被保留到class文件，当jvm加载class文件时候被遗弃，这是默认的生命周期； RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在。 这3个生命周期分别对应于：Java源文件(.java文件) —&gt; .class文件 —&gt; 内存中的字节码。 2、注解@Target表示修饰的注解能使用的范围，ElementType.METHOD表示@AnnotationTest注解只能作用在方法上。 注解处理器参照上部分，在工程中new-&gt;Module-&gt;Java Library，新建一个Java Library Module， 在该Module下创建一个文件ProcessorTest.java。在该Module下的build.gradle的dependencies中添加如下配置： 1234// 自动为processor注册implementation &apos;com.google.auto.service:auto-service:1.0-rc2&apos;// 该Module依赖上部分建立的annotation Moduleimplementation project(&apos;:annotation&apos;) com.google.auto.service:auto-service:1.0-rc2依赖的作用是为注解处理器自动注册，它会生成META-INF文件夹。 注解处理器ProcessorTest的定义如下，其中@AutoService(Processor.class)就是build.gradle中加的依赖帮助其自动注册。 12@AutoService(Processor.class) // 自动为ProcessorTest注册，生成META-INF文件public class ProcessorTest extends AbstractProcessor&#123; 注解处理器ProcessorTest主要包含以下几个部分： 1234567@Overridepublic synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); mMessager = processingEnvironment.getMessager(); mFiler = processingEnvironment.getFiler();&#125; init方法是注解处理器会自动调用的初始化方法，其中mFiler是用来生成java源文件的工具，mMessager是用来打印日志的，它们的具体使用会在后面介绍。 123456@Overridepublic Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; supportAnnotationTypes = new HashSet&lt;&gt;(); supportAnnotationTypes.add(AnnotationTest.class.getCanonicalName()); return supportAnnotationTypes;&#125; getSupportedAnnotationTypes()方法返回该注解处理器支持的注解类型，这里返回的就是我们之前声明的新的注解类型@AnnotationTest。 1234@Overridepublic SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported();&#125; getSupportedSourceVersion()方法一般就按照上述实现就行。 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnvironment) &#123; // 打印日志 mMessager.printMessage(Diagnostic.Kind.NOTE, &quot;process start&quot;); Map&lt;String, List&lt;String&gt;&gt; collectInfos = new HashMap&lt;&gt;(); for (TypeElement annotation: annotations)&#123; Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(annotation); for (Element element: elements)&#123; // 检查element是否符合我们定义的规范 if (!checkValid(element))&#123; mMessager.printMessage(Diagnostic.Kind.NOTE, &quot;checkValid not pass&quot;); return false; &#125;else &#123; ExecutableElement executableElement = (ExecutableElement) element; // 获取被注解的方法所在的类 TypeElement typeElement = (TypeElement) executableElement.getEnclosingElement(); // 获取类的全名，包括包名 String classFullName = typeElement.getQualifiedName().toString(); // 被注解的方法的名字 String methodName = executableElement.getSimpleName().toString(); List&lt;String&gt; methods = collectInfos.get(classFullName); if (methods == null)&#123; methods = new ArrayList&lt;&gt;(); collectInfos.put(classFullName, methods); &#125; methods.add(methodName); &#125; &#125; &#125; for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry: collectInfos.entrySet())&#123; mMessager.printMessage(Diagnostic.Kind.NOTE, entry.getKey()); // 生成java源文件 createJavaFile(entry.getKey(), entry.getValue()); &#125; return true;&#125; process方法是我们的主要逻辑处理的地方，主要逻辑就是收集所有有@AnnotationTest注解的方法以及其所在的类信息，然后根据每个类信息，生成一个新的类文件，并在新的类文件的特定方法中调用所有关联的注解方法。生成java源文件将使用Filer对象，具体如何使用请下载demo看源代码。 注： 1、当你点击buid project时，注解处理器将会执行，而Messager对象打印出来的日志信息可以在Gradle Console窗口中看到。 2、如果你在该Module中使用中文注解，因为该Module为java library，可能会报GBK编码错误，解决办法是在该Module的build.gradle中添加如下代码： 1234//指定编译的编码tasks.withType(JavaCompile)&#123; options.encoding = &quot;UTF-8&quot;&#125; Lib在工程中new-&gt;Module-&gt;Android Library ，新建一个Android Library Module，封装接口给调用方使用，具体逻辑请参考demo。 最终该demo的功能是点击Hello world文字，会依此执行MainActivity中使用@AnnotationTest注解的方法。]]></content>
      <categories>
        <category>注解</category>
      </categories>
      <tags>
        <tag>annotation、processor、自动生成java文件</tag>
      </tags>
  </entry>
</search>
