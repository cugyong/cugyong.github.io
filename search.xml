<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[EventBus3.0源码解析-01]]></title>
    <url>%2F2019%2F01%2F08%2FEventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01%2F</url>
    <content type="text"><![CDATA[最近在学习EventBus源码，本着学习完之后要及时总结，方便以后回顾的心态，这里做一个系列来分析EventBus的源码。本系列讨论的都是最新的EventBus3.0的源码。EventBus GitHub地址 EventBus的基本流程 ​ 官网流程图 从官网流程图可以看出，EventBus使用的是观察者模式，Publisher(发布者)调用post方法将事件发送给订阅了该事件的Subscriber(订阅者)。 Publisher(发布者)—调用post方法发布事件的类就是发布者 Subscriber(订阅者)—通过@Subscribe注解的方法就是订阅者 EventBus—负责把post方法发布的事件通知给相应的订阅者 EventBus的基本使用逻辑如下： 定义事件类型 1public static class MessageEvent &#123; /* Additional fields if needed */ &#125; 通过@Subscriber准备订阅方法 12@Subscribe(threadMode = ThreadMode.MAIN) public void onMessageEvent(MessageEvent event) &#123;/* Do something */&#125;; 其中@Subscriber可以指定三个参数： ThreadMode—指定订阅方法(上文中的onMessageEvent方法)运行在什么线程，默认是POSTING； POSTING：表示订阅方法运行在当前发布事件的线程(调用post方法的线程)； MAIN：表示订阅方法运行在UI线程。如果当前发布事件的线程是UI线程，则订阅方法直接运行，否则，事件入队列等待触发订阅方法(入队列的方式不阻塞线程)； MAIN_ORDERED：表示订阅方法运行在UI线程。它和MAIN的区别是，事件会直接入队列等待触发订阅方法； BACKGROUND：表示订阅方法运行在后台线程。如果当前发布事件的线程是后台线程，则订阅方法直接运行，否则，订阅方法将会运行在一个唯一的后台线程中，该唯一的后台线程将会负责运行所有有BACKGROUND标识的订阅方法； ASYNC：表示订阅方法将总是运行在一个新的后台线程，即即使当前发布事件的线程是后台线程，它也会运行在一个新的后台线程。 priority—表示该方法的优先级，默认是0。当发布事件的时候，同一线程中，优先级值越大的方法，会被更早调用； sticky—如果为true，将会发送最新的sticky事件给相应的订阅者，默认为false； sticky的使用一般为：如果用户希望先调用postSticky发布事件，再注册订阅者接收该事件，则可以指定sticky为true。 注册和取消注册包含订阅方法的订阅者 比如在Activity中，方式一般如下： 123456789101112131415@Override public void onStart() &#123; super.onStart(); EventBus.getDefault().register(this); &#125; @Override public void onStop() &#123; super.onStop(); EventBus.getDefault().unregister(this); &#125; // 订阅方法 @Subscribe(threadMode = ThreadMode.MAIN) public void onMessageEvent(MessageEvent event) &#123;/* Do something */&#125;; 发布事件 1EventBus.getDefault().post(new MessageEvent()); 通过上文，我们知道eventbus的基本使用流程主要有四个步骤，而其中涉及eventbus的主要有三个方法，分别为register注册订阅者，unregister取消注册，post发布事件。后续我将分别以这三个方法为入口，对eventbus源码进行解析，敬请期待。]]></content>
      <categories>
        <category>EventBus3.0</category>
      </categories>
      <tags>
        <tag>EventBus3.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android开发-常用网址]]></title>
    <url>%2F2019%2F01%2F05%2Fandroid%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E7%BD%91%E5%9D%80%2F</url>
    <content type="text"><![CDATA[android development 网址 https://developer.android.com/guide/]]></content>
  </entry>
  <entry>
    <title><![CDATA[安卓注解处理器-processor]]></title>
    <url>%2F2019%2F01%2F04%2F%E5%AE%89%E5%8D%93%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8-processor%2F</url>
    <content type="text"><![CDATA[最近在学习安卓开源框架发现，很多的开源框架都使用到了注解处理器，例如EventBus3.0。本文通过一个简单的Demo来介绍如何使用注解处理器。Demo链接为https://github.com/cugyong/AnnotationProcessor-sample ，如果喜欢的话，欢迎大家给star。 Demo需求描述用户通过执行一个传入参数为A（类对象）的静态方法，该方法会最终把参数A中加了特定注解的所有方法执行一遍。 需求实现 整个项目分为四个部分： 注解–要使用的注解类型，这部分通常也可以放在lib中； 注解处理器–要对注解进行处理的逻辑，包括收集有特定注解类型的方法信息以及生成特定的java文件； lib–封装合适的接口，供具体调用方调用； sample–具体的调用方逻辑。 首先新建一个安卓工程，点击运行展示的是hello world。 注解在上述工程中new-&gt;Module-&gt;Java Library，新建一个Java Library Module，命名为annotation。在该Module下创建一个文件AnnotationTest.java， AnnotationTest.java里面代码如下： 12345@Retention(RetentionPolicy.CLASS)@Target(ElementType.METHOD)public @interface AnnotationTest &#123; String name() default &quot;test&quot;;&#125; 1、注解@Retention按生命周期来划分可分为3类： RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃； RetentionPolicy.CLASS：注解被保留到class文件，当jvm加载class文件时候被遗弃，这是默认的生命周期； RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在。 这3个生命周期分别对应于：Java源文件(.java文件) —&gt; .class文件 —&gt; 内存中的字节码。 2、注解@Target表示修饰的注解能使用的范围，ElementType.METHOD表示@AnnotationTest注解只能作用在方法上。 注解处理器参照上部分，在工程中new-&gt;Module-&gt;Java Library，新建一个Java Library Module， 在该Module下创建一个文件ProcessorTest.java。在该Module下的build.gradle的dependencies中添加如下配置： 1234// 自动为processor注册implementation &apos;com.google.auto.service:auto-service:1.0-rc2&apos;// 该Module依赖上部分建立的annotation Moduleimplementation project(&apos;:annotation&apos;) com.google.auto.service:auto-service:1.0-rc2依赖的作用是为注解处理器自动注册，它会生成META-INF文件夹。 注解处理器ProcessorTest的定义如下，其中@AutoService(Processor.class)就是build.gradle中加的依赖帮助其自动注册。 12@AutoService(Processor.class) // 自动为ProcessorTest注册，生成META-INF文件public class ProcessorTest extends AbstractProcessor&#123; 注解处理器ProcessorTest主要包含以下几个部分： 1234567@Overridepublic synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); mMessager = processingEnvironment.getMessager(); mFiler = processingEnvironment.getFiler();&#125; init方法是注解处理器会自动调用的初始化方法，其中mFiler是用来生成java源文件的工具，mMessager是用来打印日志的，它们的具体使用会在后面介绍。 123456@Overridepublic Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; supportAnnotationTypes = new HashSet&lt;&gt;(); supportAnnotationTypes.add(AnnotationTest.class.getCanonicalName()); return supportAnnotationTypes;&#125; getSupportedAnnotationTypes()方法返回该注解处理器支持的注解类型，这里返回的就是我们之前声明的新的注解类型@AnnotationTest。 1234@Overridepublic SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported();&#125; getSupportedSourceVersion()方法一般就按照上述实现就行。 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnvironment) &#123; // 打印日志 mMessager.printMessage(Diagnostic.Kind.NOTE, &quot;process start&quot;); Map&lt;String, List&lt;String&gt;&gt; collectInfos = new HashMap&lt;&gt;(); for (TypeElement annotation: annotations)&#123; Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(annotation); for (Element element: elements)&#123; // 检查element是否符合我们定义的规范 if (!checkValid(element))&#123; mMessager.printMessage(Diagnostic.Kind.NOTE, &quot;checkValid not pass&quot;); return false; &#125;else &#123; ExecutableElement executableElement = (ExecutableElement) element; // 获取被注解的方法所在的类 TypeElement typeElement = (TypeElement) executableElement.getEnclosingElement(); // 获取类的全名，包括包名 String classFullName = typeElement.getQualifiedName().toString(); // 被注解的方法的名字 String methodName = executableElement.getSimpleName().toString(); List&lt;String&gt; methods = collectInfos.get(classFullName); if (methods == null)&#123; methods = new ArrayList&lt;&gt;(); collectInfos.put(classFullName, methods); &#125; methods.add(methodName); &#125; &#125; &#125; for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry: collectInfos.entrySet())&#123; mMessager.printMessage(Diagnostic.Kind.NOTE, entry.getKey()); // 生成java源文件 createJavaFile(entry.getKey(), entry.getValue()); &#125; return true;&#125; process方法是我们的主要逻辑处理的地方，主要逻辑就是收集所有有@AnnotationTest注解的方法以及其所在的类信息，然后根据每个类信息，生成一个新的类文件，并在新的类文件的特定方法中调用所有关联的注解方法。生成java源文件将使用Filer对象，具体如何使用请下载demo看源代码。 注： 1、当你点击buid project时，注解处理器将会执行，而Messager对象打印出来的日志信息可以在Gradle Console窗口中看到。 2、如果你在该Module中使用中文注解，因为该Module为java library，可能会报GBK编码错误，解决办法是在该Module的build.gradle中添加如下代码： 1234//指定编译的编码tasks.withType(JavaCompile)&#123; options.encoding = &quot;UTF-8&quot;&#125; Lib在工程中new-&gt;Module-&gt;Android Library ，新建一个Android Library Module，封装接口给调用方使用，具体逻辑请参考demo。 最终该demo的功能是点击Hello world文字，会依此执行MainActivity中使用@AnnotationTest注解的方法。]]></content>
      <categories>
        <category>注解</category>
      </categories>
      <tags>
        <tag>annotation、processor、自动生成java文件</tag>
      </tags>
  </entry>
</search>
