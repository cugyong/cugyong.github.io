<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>EventBus3.0源码解析-03</title>
      <link href="/2019/01/09/EventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-03/"/>
      <url>/2019/01/09/EventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-03/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cugyong.github.io/2019/01/08/EventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02/" target="_blank" rel="noopener">EventBus3.0源码解析-02</a>中我们介绍到，当用户调用EventBus的register方法时，会收集保存相应的订阅信息。而在收集订阅信息的过程中，有两种方式，一种通过反射收集，一种通过注解处理器在编译期生成的索引文件进行收集。第一种方式已经在<a href="https://cugyong.github.io/2019/01/08/EventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02/" target="_blank" rel="noopener">EventBus3.0源码解析-02</a>中进行了详细的介绍，本文将介绍通过索引文件的方式。</p><h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>如果读者对注解处理器还不是很了解，可以阅读<a href="https://cugyong.github.io/2019/01/04/%E5%AE%89%E5%8D%93%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8-processor/" target="_blank" rel="noopener">这篇文章</a>进行学习。本文我假设大家对注解处理器已经有了基本的了解，将主要介绍EventBus3.0的注解处理器逻辑。其主要实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) &#123;</span><br><span class="line">    Messager messager = processingEnv.getMessager();</span><br><span class="line">    try &#123;</span><br><span class="line">        String index = processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX);</span><br><span class="line">        if (index == null) &#123;</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.ERROR, &quot;No option &quot; + OPTION_EVENT_BUS_INDEX +</span><br><span class="line">                    &quot; passed to annotation processor&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        verbose = Boolean.parseBoolean(processingEnv.getOptions().get(OPTION_VERBOSE));</span><br><span class="line">        int lastPeriod = index.lastIndexOf(&apos;.&apos;);</span><br><span class="line">        String indexPackage = lastPeriod != -1 ? index.substring(0, lastPeriod) : null;</span><br><span class="line"></span><br><span class="line">        round++;</span><br><span class="line">        if (verbose) &#123;</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.NOTE, &quot;Processing round &quot; + round + &quot;, new annotations: &quot; +</span><br><span class="line">                    !annotations.isEmpty() + &quot;, processingOver: &quot; + env.processingOver());</span><br><span class="line">        &#125;</span><br><span class="line">        if (env.processingOver()) &#123;</span><br><span class="line">            if (!annotations.isEmpty()) &#123;</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.ERROR,</span><br><span class="line">                        &quot;Unexpected processing state: annotations still available after processing over&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (annotations.isEmpty()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (writerRoundDone) &#123;</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.ERROR,</span><br><span class="line">                    &quot;Unexpected processing state: annotations still available after writing.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        collectSubscribers(annotations, env, messager);</span><br><span class="line">        checkForSubscribersToSkip(messager, indexPackage);</span><br><span class="line"></span><br><span class="line">        if (!methodsByClass.isEmpty()) &#123;</span><br><span class="line">            createInfoIndexFile(index);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.WARNING, &quot;No @Subscribe annotations found&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        writerRoundDone = true;</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        // IntelliJ does not handle exceptions nicely, so log and print a message</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, &quot;Unexpected error in EventBusAnnotationProcessor: &quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码我们知道，其核心逻辑应该在<strong>collectSubscribers</strong>，<strong>checkForSubscribersToSkip</strong>和<strong>createInfoIndexFile</strong>三个方法中。</p><p><strong>注意</strong>这句代码String index = processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX)，OPTION_EVENT_BUS_INDEX的值为“eventBusIndex”，它将获取注解处理器的可选参数，是由用户指定的，那么怎么指定呢？</p><p>1、由@SupportedOptions指定注解处理器可以接收哪些可选参数：</p><p><img src="/2019/01/09/EventBus3源码解析-03/注解处理器指定可选参数.png" alt="指定可选参数"></p><p>2、在app工程的build.gradle文件中传入参数值：</p><p><img src="/2019/01/09/EventBus3源码解析-03/传入注解处理器可选参数.png" alt="传入可选参数"></p><p>后面我们接着介绍<strong>collectSubscribers</strong>，<strong>checkForSubscribersToSkip</strong>和<strong>createInfoIndexFile</strong>三个方法。</p><h3 id="collectSubscribers方法"><a href="#collectSubscribers方法" class="headerlink" title="collectSubscribers方法"></a>collectSubscribers方法</h3><p><strong>collectSubscribers</strong>方法的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void collectSubscribers(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env, Messager messager) &#123;</span><br><span class="line">    for (TypeElement annotation : annotations) &#123;</span><br><span class="line">    // 找到所有有annotation注解的元素信息</span><br><span class="line">        Set&lt;? extends Element&gt; elements = env.getElementsAnnotatedWith(annotation);</span><br><span class="line">        for (Element element : elements) &#123;</span><br><span class="line">            // 元素是否是可执行元素，比如方法</span><br><span class="line">            if (element instanceof ExecutableElement) &#123;</span><br><span class="line">                ExecutableElement method = (ExecutableElement) element;</span><br><span class="line">                // 检查方法定义是否符合规范</span><br><span class="line">                if (checkHasNoErrors(method, messager)) &#123;</span><br><span class="line">                    // 方法所在的类元素</span><br><span class="line">                    TypeElement classElement = (TypeElement) method.getEnclosingElement();</span><br><span class="line">                    // 保存找到的元素</span><br><span class="line">                    methodsByClass.putElement(classElement, method);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.ERROR, &quot;@Subscribe is only valid for methods&quot;, element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>collectSubscribers方法逻辑相对简单，相信读者通过阅读代码注释就能明白，<strong>就是把所有有用的信息收集到了methodsByClass变量中</strong>。其中，checkHasNoErrors方法的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private boolean checkHasNoErrors(ExecutableElement element, Messager messager) &#123;</span><br><span class="line">    // 方法修饰符是否包含static</span><br><span class="line">    if (element.getModifiers().contains(Modifier.STATIC)) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, &quot;Subscriber method must not be static&quot;, element);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 方法修饰符是否包含public</span><br><span class="line">    if (!element.getModifiers().contains(Modifier.PUBLIC)) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, &quot;Subscriber method must be public&quot;, element);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    List&lt;? extends VariableElement&gt; parameters = ((ExecutableElement) element).getParameters();</span><br><span class="line">    // 方法是否只有一个参数</span><br><span class="line">    if (parameters.size() != 1) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, &quot;Subscriber method must have exactly 1 parameter&quot;, element);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="checkForSubscribersToSkip"><a href="#checkForSubscribersToSkip" class="headerlink" title="checkForSubscribersToSkip"></a>checkForSubscribersToSkip</h3><p>checkForSubscribersToSkip方法的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">private void checkForSubscribersToSkip(Messager messager, String myPackage) &#123;</span><br><span class="line">    for (TypeElement skipCandidate : methodsByClass.keySet()) &#123;</span><br><span class="line">        TypeElement subscriberClass = skipCandidate;</span><br><span class="line">        while (subscriberClass != null) &#123;</span><br><span class="line">            // subscriberClass类在myPackage包名下面是否可见</span><br><span class="line">            if (!isVisible(myPackage, subscriberClass)) &#123;</span><br><span class="line">                boolean added = classesToSkip.add(skipCandidate);</span><br><span class="line">                if (added) &#123;</span><br><span class="line">                    String msg;</span><br><span class="line">                    if (subscriberClass.equals(skipCandidate)) &#123;</span><br><span class="line">                        msg = &quot;Falling back to reflection because class is not public&quot;;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        msg = &quot;Falling back to reflection because &quot; + skipCandidate +</span><br><span class="line">                                &quot; has a non-public super class&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    messager.printMessage(Diagnostic.Kind.NOTE, msg, subscriberClass);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberClass);</span><br><span class="line">            if (methods != null) &#123;</span><br><span class="line">                for (ExecutableElement method : methods) &#123;</span><br><span class="line">                    String skipReason = null;</span><br><span class="line">                    VariableElement param = method.getParameters().get(0);</span><br><span class="line">                    TypeMirror typeMirror = getParamTypeMirror(param, messager);</span><br><span class="line">                    if (!(typeMirror instanceof DeclaredType) ||</span><br><span class="line">                            !(((DeclaredType) typeMirror).asElement() instanceof TypeElement)) &#123;</span><br><span class="line">                        skipReason = &quot;event type cannot be processed&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (skipReason == null) &#123;</span><br><span class="line">                        TypeElement eventTypeElement = (TypeElement) ((DeclaredType) typeMirror).asElement();</span><br><span class="line">                        // eventTypeElement事件类在myPackage包名下面是否可见</span><br><span class="line">                        if (!isVisible(myPackage, eventTypeElement)) &#123;</span><br><span class="line">                            skipReason = &quot;event type is not public&quot;;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (skipReason != null) &#123;</span><br><span class="line">                        boolean added = classesToSkip.add(skipCandidate);</span><br><span class="line">                        if (added) &#123;</span><br><span class="line">                            String msg = &quot;Falling back to reflection because &quot; + skipReason;</span><br><span class="line">                            if (!subscriberClass.equals(skipCandidate)) &#123;</span><br><span class="line">                                msg += &quot; (found in super class for &quot; + skipCandidate + &quot;)&quot;;</span><br><span class="line">                            &#125;</span><br><span class="line">                            messager.printMessage(Diagnostic.Kind.NOTE, msg, param);</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            subscriberClass = getSuperclass(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checkForSubscribersToSkip方法的逻辑是，因为我们将在myPackage包名下面创建索引文件，而如果某些订阅类或者父类在myPackage包名下面是不可见的，那么这些类不应该创建相应的索引代码。同样的，如果订阅方法的事件参数类在myPackage包名下面是不可见的，那么这些类也不应该创建相应的索引代码。</p><h3 id="createInfoIndexFile"><a href="#createInfoIndexFile" class="headerlink" title="createInfoIndexFile"></a>createInfoIndexFile</h3><p>createInfoIndexFile方法就是按照一定规则自动生成java代码，创建相应java源文件。下面通过一个具体的例子来说明createInfoIndexFile方法会生成什么样的文件。</p><p>1、在OtherClass类中使用@Subscribe声明了一个订阅方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class OtherClass &#123;</span><br><span class="line"></span><br><span class="line">    @Subscribe()</span><br><span class="line">    public void test(String str)&#123;</span><br><span class="line">        Log.d(&quot;eventbusTest&quot;, &quot;OtherClass&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在MainActivity类中使用@Subscribe声明了一个订阅方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">@Subscribe()</span><br><span class="line">    public void test(String str)&#123;</span><br><span class="line">        Log.d(&quot;eventbusTest&quot;, &quot;MainActivity&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、点击build，会在你通过eventBusIndex指定的路径下面生成一个索引文件，本文指定是”com.yong.cugyong.eventbus_sample.MyEventBusIndex“：</p><p><img src="/2019/01/09/EventBus3源码解析-03/索引文件路径.png" alt="索引文件路径"></p><p>MyEventBusIndex文件的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/** This class is generated by EventBus, do not edit. */</span><br><span class="line">public class MyEventBusIndex implements SubscriberInfoIndex &#123;</span><br><span class="line">    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line"></span><br><span class="line">        putIndex(new SimpleSubscriberInfo(MainActivity.class, true, new SubscriberMethodInfo[] &#123;</span><br><span class="line">            new SubscriberMethodInfo(&quot;test&quot;, String.class),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(new SimpleSubscriberInfo(OtherClass.class, true, new SubscriberMethodInfo[] &#123;</span><br><span class="line">            new SubscriberMethodInfo(&quot;test&quot;, String.class),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void putIndex(SubscriberInfo info) &#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        if (info != null) &#123;</span><br><span class="line">            return info;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里大家只要知道编译工程之后会生成这样一个文件，再下一部分将告诉大家具体含义。</p><h2 id="索引文件使用"><a href="#索引文件使用" class="headerlink" title="索引文件使用"></a>索引文件使用</h2><p>在文章开头我们介绍到，用户调用EventBus的register方法时，会收集保存相应的订阅信息，而这里我们就介绍怎么通过索引文件找到想要的信息，对register逻辑还不是很了解的朋友可以先看一下<a href="https://cugyong.github.io/2019/01/08/EventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02/" target="_blank" rel="noopener">EventBus3.0源码解析-02</a>。</p><p>通过索引文件收集信息的入口函数是SubscriberMethodFinder类的findUsingInfo方法，该方法的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    while (findState.clazz != null) &#123;</span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        if (findState.subscriberInfo != null) &#123;</span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        // 索引文件中未找到，则使用反射</span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    return getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法里面的大多数逻辑我们都在<a href="https://cugyong.github.io/2019/01/08/EventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02/" target="_blank" rel="noopener">EventBus3.0源码解析-02</a>中进行了介绍，这里我们只介绍不同点<strong>getSubscriberInfo</strong>方法，其实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private SubscriberInfo getSubscriberInfo(FindState findState) &#123;</span><br><span class="line">    // 如果需要找的信息已经存在，直接返回</span><br><span class="line">    if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) &#123;</span><br><span class="line">        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">        if (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">            return superclassInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 通常会直接走这一块逻辑</span><br><span class="line">    if (subscriberInfoIndexes != null) &#123;</span><br><span class="line">        // 遍历所有索引文件</span><br><span class="line">        for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">            if (info != null) &#123;</span><br><span class="line">                return info;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法遍历所有索引文件，调用索引文件中getSubscriberInfo方法根据订阅类寻找订阅信息。因为这种寻找订阅信息的方式没有反射，所以效率很高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>EventBus通过索引文件寻找订阅信息，是通过在编译期通过注解处理器生成相应的索引文件，然后在运行期使用索引文件寻找订阅信息，这样在运行期就不需要使用到反射了，提高了效率。</p>]]></content>
      
      
      <categories>
          
          <category> EventBus3.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EventBus3.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventBus3.0源码解析-02</title>
      <link href="/2019/01/08/EventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02/"/>
      <url>/2019/01/08/EventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cugyong.github.io/2019/01/08/EventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01/#more" target="_blank" rel="noopener">EventBus3.0源码解析-01</a>这篇文章简单的介绍了EventBus的使用流程，我们知道EventBus有三个主要入口方法，分别为</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(Object);</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(Object);</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(Object);</span><br></pre></td></tr></table></figure></li></ul><p>本文将通过register入口方法及其逻辑，分析EventBus源码。</p><p>EventBus的register方法实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>register函数主要实现了两个功能，1、将订阅类中所有订阅方法收集；2、按一定规则保存收集的信息。</p><h2 id="订阅方法收集"><a href="#订阅方法收集" class="headerlink" title="订阅方法收集"></a>订阅方法收集</h2><p>订阅方法收集主要由<strong>SubscriberMethodFinder</strong>类的findSubscriberMethods函数实现，我们看下其具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">    // 先从缓存中获取，即之前该类是否注册使用过</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    if (subscriberMethods != null) &#123;</span><br><span class="line">        return subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 是否忽略注解处理器生成的索引文件</span><br><span class="line">    if (ignoreGeneratedIndex) &#123;</span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    &#125;</span><br><span class="line">    if (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</span><br><span class="line">                + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        return subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、如果参数中的subscriberClass类之前注册过，那么直接从METHOD_CACHE缓存中获取信息返回。</p><p>2、根据ignoreGeneratedIndex判断是否要根据注解处理器在编译期生成的索引文件来寻找订阅方法信息，该方式是从EventBus3.0中引入的，目的是为了提高EventBus的整体效率。如果ignoreGeneratedIndex为true，则使用反射来寻找订阅方法信息，否则，先根据生成的索引文件来寻找订阅方法信息，索引文件中找不到，再使用反射寻找。</p><p>3、如果找到的订阅方法信息非空，则将这些信息缓存在METHOD_CACHE中。</p><p>第1、3步没有什么好讲的内容，主要的内容在第2步。由于根据索引文件寻找订阅方法信息的方式还涉及注解处理器，稍微复杂，所以会单独开一篇文章讲这块。本文主要介绍通过反射来寻找订阅方法信息的方式。</p><p>我们来看一下<strong>findUsingReflection</strong>的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    // 遍历订阅类以及其父类</span><br><span class="line">    while (findState.clazz != null) &#123;</span><br><span class="line">        findUsingReflectionInSingleClass(findState);</span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    return getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private FindState prepareFindState() &#123;</span><br><span class="line">    synchronized (FIND_STATE_POOL) &#123;</span><br><span class="line">        for (int i = 0; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">            FindState state = FIND_STATE_POOL[i];</span><br><span class="line">            if (state != null) &#123;</span><br><span class="line">                FIND_STATE_POOL[i] = null;</span><br><span class="line">                return state;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new FindState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>prepareFindState</strong>()方法会尝试从缓存中寻找是否有现存的FindState对象，如果有，则直接使用缓存的FindState对象，否则，直接new一个FindState对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">// 保存订阅类信息</span><br><span class="line">    this.subscriberClass = clazz = subscriberClass;</span><br><span class="line">    // 是否忽略父类</span><br><span class="line">    skipSuperClasses = false;</span><br><span class="line">    subscriberInfo = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>initForSubscriber</strong>方法就是简单的初始化了一些参数。</p><p>接下来我们看下核心方法<strong>findUsingReflectionInSingleClass</strong>的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</span><br><span class="line">    Method[] methods;</span><br><span class="line">    try &#123;</span><br><span class="line">        // getDeclaredMethods()方法的效率要优于getMethods()</span><br><span class="line">        methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">    &#125; catch (Throwable th) &#123;</span><br><span class="line">        methods = findState.clazz.getMethods();</span><br><span class="line">        findState.skipSuperClasses = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for (Method method : methods) &#123;</span><br><span class="line">        // 获取方法的修饰符, 比如public, static等修饰符</span><br><span class="line">        int modifiers = method.getModifiers();</span><br><span class="line">        if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123;</span><br><span class="line">        // 获取方法的参数信息</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            // 方法只有一个参数</span><br><span class="line">            if (parameterTypes.length == 1) &#123;</span><br><span class="line">                // 获取方法的@Subscribe注解信息</span><br><span class="line">                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                // 如果方法有@Subscribe注解信息</span><br><span class="line">                if (subscribeAnnotation != null) &#123;</span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[0];</span><br><span class="line">                    // 检查当前method是否是有效的订阅方法</span><br><span class="line">                    if (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        // 如果当前method是有效的订阅方法，则把该订阅方法收集起来</span><br><span class="line">                        ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                        findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                throw new EventBusException(&quot;@Subscribe method &quot; + methodName +</span><br><span class="line">                        &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">            String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">            throw new EventBusException(methodName +</span><br><span class="line">                    &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findUsingReflectionInSingleClass方法加了详细的注解，大多数逻辑都能直接看代码注释弄明白。这里主要要介绍的是<strong>findState.checkAdd(method, eventType)</strong>方法，checkAdd的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">boolean checkAdd(Method method, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">    // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.</span><br><span class="line">    // Usually a subscriber doesn&apos;t have methods listening to the same event type.</span><br><span class="line">    Object existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">    if (existing == null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (existing instanceof Method) &#123;</span><br><span class="line">            if (!checkAddWithMethodSignature((Method) existing, eventType)) &#123;</span><br><span class="line">                // Paranoia check</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            // Put any non-Method object to &quot;consume&quot; the existing Method</span><br><span class="line">            anyMethodByEventType.put(eventType, this);</span><br><span class="line">        &#125;</span><br><span class="line">        return checkAddWithMethodSignature(method, eventType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到同一个类里面通常只会有一个方法监听同一类事件，为了效率，所以EventBus先根据事件类型去匹配同一个类中是否已经有添加过的方法监听同一类事件，如果没有，则直接认为该方法为有效订阅方法，如果之前已经添加过方法监听同一类事件，则通过checkAddWithMethodSignature来判断该方法是否为有效订阅方法。<strong>checkAddWithMethodSignature</strong>的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">    methodKeyBuilder.setLength(0);</span><br><span class="line">    methodKeyBuilder.append(method.getName());</span><br><span class="line">    methodKeyBuilder.append(&apos;&gt;&apos;).append(eventType.getName());</span><br><span class="line"></span><br><span class="line">    String methodKey = methodKeyBuilder.toString();</span><br><span class="line">    Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">    Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">    // methodClassOld 是否是 methodClass的父类或者接口</span><br><span class="line">    if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123;</span><br><span class="line">        // Only add if not already found in a sub class</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Revert the put, old class is further down the class hierarchy</span><br><span class="line">        subscriberClassByMethodKey.put(methodKey, methodClassOld);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据一定规则计算出方法的唯一特征名称，如果具有该特征名称的方法之前还没有添加过，则认为当前方法为有效订阅方法。否则，如果之前添加过的方法所在的类是当前方法所在类的父类或者接口，考虑到子类重写，认为当前方法为有效订阅方法。否则认为当前方法为非有效订阅方法。</p><p>通过上面的多次调用<strong>findUsingReflectionInSingleClass</strong>方法，我们已经把有效的订阅信息收集到了findState的subscriberMethods变量中。</p><h2 id="保存所有订阅信息"><a href="#保存所有订阅信息" class="headerlink" title="保存所有订阅信息"></a>保存所有订阅信息</h2><p>我们再回到findUsingReflection方法，接着会调用<strong>getMethodsAndRelease(findState)</strong>方法，我们看看它的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123;</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">    findState.recycle();</span><br><span class="line">    synchronized (FIND_STATE_POOL) &#123;</span><br><span class="line">        for (int i = 0; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">            if (FIND_STATE_POOL[i] == null) &#123;</span><br><span class="line">                FIND_STATE_POOL[i] = findState;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return subscriberMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它其实做的事情就是把findState放入到缓存中，然后返回刚刚收集到的有效订阅信息。</p><p>现在我们回到<strong>register</strong>方法，我们收集到了有效的订阅信息List<subscribermethod>，接着会循环调用<strong>subscribe(subscriber, subscriberMethod)</strong>方法，我们看看这个方法的实现：</subscribermethod></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// Must be called in synchronized block</span><br><span class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    if (subscriptions == null) &#123;</span><br><span class="line">        subscriptions = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;</span><br><span class="line">                    + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 优先级高的放列表的前面</span><br><span class="line">    int size = subscriptions.size();</span><br><span class="line">    for (int i = 0; i &lt;= size; i++) &#123;</span><br><span class="line">        if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    if (subscribedEvents == null) &#123;</span><br><span class="line">        subscribedEvents = new ArrayList&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">    if (subscriberMethod.sticky) &#123;</span><br><span class="line">        // 是否考虑注册方法的参数，事件的继承关系</span><br><span class="line">        if (eventInheritance) &#123;</span><br><span class="line">            // Existing sticky events of all subclasses of eventType have to be considered.</span><br><span class="line">            // Note: Iterating over all events may be inefficient with lots of sticky events,</span><br><span class="line">            // thus data structure should be changed to allow a more efficient lookup</span><br><span class="line">            // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    Object stickyEvent = entry.getValue();</span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的代码虽然很长，但是其只做了三件事情，1、将订阅信息以事件类型为key保存在subscriptionsByEventType变量中（方便post方法调用的时候，以事件为key寻找订阅信息）；2、将事件类型以订阅类为key保存在typesBySubscriber变量中（方便unregister方法调用的时候，以订阅类为key寻找事件类型，然后根据subscriptionsByEventType变量找到订阅信息）；3、处理sticky事件逻辑。关于第3点，考虑到本文篇幅，我将另外开一篇文章进行分析。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以通过调用<strong>register</strong>方法，最终订阅方法信息会被最终保存在<strong>subscriptionsByEventType</strong>变量和<strong>typesBySubscriber</strong>变量中。</p><p>如果你喜欢，感谢给个赞。如果有什么问题，欢迎评论。</p>]]></content>
      
      
      <categories>
          
          <category> EventBus3.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EventBus3.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventBus3.0源码解析-01</title>
      <link href="/2019/01/08/EventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01/"/>
      <url>/2019/01/08/EventBus3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01/</url>
      
        <content type="html"><![CDATA[<p>最近在学习EventBus源码，本着学习完之后要及时总结，方便以后回顾的心态，这里做一个系列来分析EventBus的源码。本系列讨论的都是最新的EventBus3.0的源码。<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus GitHub地址</a>  <a id="more"></a></p><p><strong>EventBus在gradle工程中引入的方式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;org.greenrobot:eventbus:3.1.1&apos;</span><br></pre></td></tr></table></figure><h1 id="EventBus的基本流程"><a href="#EventBus的基本流程" class="headerlink" title="EventBus的基本流程"></a>EventBus的基本流程</h1><p><img src="/2019/01/08/EventBus3源码解析-01/eventbus调用流程.png" alt="基本流程"></p><p>从官网流程图可以看出，EventBus使用的是观察者模式，Publisher(发布者)调用post方法将事件发送给订阅了该事件的Subscriber(订阅者)。</p><ul><li>Publisher(发布者)—调用post方法发布事件的类就是发布者</li><li>Subscriber(订阅者)—通过@Subscribe注解的方法就是订阅者</li><li>EventBus—负责把post方法发布的事件通知给相应的订阅者</li></ul><p><strong>EventBus的基本使用逻辑如下：</strong></p><ol><li><p>定义事件类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static class MessageEvent &#123; /* Additional fields if needed */ &#125;</span><br></pre></td></tr></table></figure></li><li><p>通过@Subscriber准备订阅方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe(threadMode = ThreadMode.MAIN)  </span><br><span class="line">public void onMessageEvent(MessageEvent event) &#123;/* Do something */&#125;;</span><br></pre></td></tr></table></figure><p>其中@Subscriber可以指定三个参数：</p><ul><li><p>ThreadMode—指定订阅方法(上文中的onMessageEvent方法)运行在什么线程，默认是POSTING；</p><p>POSTING：表示订阅方法运行在当前发布事件的线程(调用post方法的线程)；</p><p>MAIN：表示订阅方法运行在UI线程。如果当前发布事件的线程是UI线程，则订阅方法直接运行，否则，事件入队列等待触发订阅方法(入队列的方式不阻塞线程)；</p><p>MAIN_ORDERED：表示订阅方法运行在UI线程。它和MAIN的区别是，事件会直接入队列等待触发订阅方法；</p><p>BACKGROUND：表示订阅方法运行在后台线程。如果当前发布事件的线程是后台线程，则订阅方法直接运行，否则，订阅方法将会运行在一个唯一的后台线程中，该唯一的后台线程将会负责运行所有有BACKGROUND标识的订阅方法；</p><p>ASYNC：表示订阅方法将总是运行在一个新的后台线程，即即使当前发布事件的线程是后台线程，它也会运行在一个新的后台线程。</p></li><li><p>priority—表示该方法的优先级，默认是0。当发布事件的时候，同一线程中，优先级值越大的方法，会被更早调用；</p></li><li><p>sticky—如果为true，将会发送最新的sticky事件给相应的订阅者，默认为false；</p><p>sticky的使用一般为：如果用户希望先调用postSticky发布事件，再注册订阅者接收该事件，则可以指定sticky为true。</p></li></ul></li><li><p>注册和取消注册包含订阅方法的订阅者</p><p>比如在Activity中，方式一般如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public void onStart() &#123;</span><br><span class="line">     super.onStart();</span><br><span class="line">     EventBus.getDefault().register(this);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void onStop() &#123;</span><br><span class="line">     super.onStop();</span><br><span class="line">     EventBus.getDefault().unregister(this);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // 订阅方法</span><br><span class="line"> @Subscribe(threadMode = ThreadMode.MAIN)  </span><br><span class="line"> public void onMessageEvent(MessageEvent event) &#123;/* Do something */&#125;;</span><br></pre></td></tr></table></figure></li><li><p>发布事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(new MessageEvent());</span><br></pre></td></tr></table></figure></li></ol><p>通过上文，我们知道eventbus的基本使用流程主要有四个步骤，而其中涉及eventbus的主要有三个方法，分别为register注册订阅者，unregister取消注册，post发布事件。后续我将分别以这三个方法为入口，对eventbus源码进行解析，敬请期待。</p>]]></content>
      
      
      <categories>
          
          <category> EventBus3.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EventBus3.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android开发-常用网址</title>
      <link href="/2019/01/05/android%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E7%BD%91%E5%9D%80/"/>
      <url>/2019/01/05/android%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E7%BD%91%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h5 id="android-development-网址"><a href="#android-development-网址" class="headerlink" title="android development 网址"></a>android development 网址</h5><ul><li><a href="https://developer.android.com/guide/" target="_blank" rel="noopener">https://developer.android.com/guide/</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安卓注解处理器-processor</title>
      <link href="/2019/01/04/%E5%AE%89%E5%8D%93%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8-processor/"/>
      <url>/2019/01/04/%E5%AE%89%E5%8D%93%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8-processor/</url>
      
        <content type="html"><![CDATA[<p>最近在学习安卓开源框架发现，很多的开源框架都使用到了注解处理器，例如EventBus3.0。本文通过一个简单的Demo来介绍如何使用注解处理器。Demo链接为<a href="https://github.com/cugyong/AnnotationProcessor-sample" target="_blank" rel="noopener">https://github.com/cugyong/AnnotationProcessor-sample</a> ，如果喜欢的话，欢迎大家给star。<a id="more"></a></p><h2 id="Demo需求描述"><a href="#Demo需求描述" class="headerlink" title="Demo需求描述"></a>Demo需求描述</h2><p>用户通过执行一个传入参数为A（类对象）的静态方法，该方法会最终把参数A中加了特定注解的所有方法执行一遍。</p><h2 id="需求实现"><a href="#需求实现" class="headerlink" title="需求实现"></a>需求实现</h2><p><img src="/2019/01/04/安卓注解处理器-processor/框架流程.png" alt="框架流程"></p><p>整个项目分为四个部分：</p><ul><li>注解–要使用的注解类型，这部分通常也可以放在lib中；</li><li>注解处理器–要对注解进行处理的逻辑，包括收集有特定注解类型的方法信息以及生成特定的java文件；</li><li>lib–封装合适的接口，供具体调用方调用；</li><li>sample–具体的调用方逻辑。</li></ul><p>首先新建一个安卓工程，点击运行展示的是hello world。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>在上述工程中new-&gt;Module-&gt;Java Library，新建一个Java Library Module，命名为annotation。在该Module下创建一个文件AnnotationTest.java，</p><p><img src="/2019/01/04/安卓注解处理器-processor/annotation.png" alt="annotation"></p><p>AnnotationTest.java里面代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface AnnotationTest &#123;</span><br><span class="line">    String name() default &quot;test&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、注解@Retention按生命周期来划分可分为3类：</p><ul><li>RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；</li><li>RetentionPolicy.CLASS：注解被保留到class文件，当jvm加载class文件时候被遗弃，这是默认的生命周期；</li><li>RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在。</li></ul><p>这3个生命周期分别对应于：Java源文件(.java文件) —&gt; .class文件 —&gt; 内存中的字节码。</p><p>2、注解@Target表示修饰的注解能使用的范围，ElementType.METHOD表示@AnnotationTest注解只能作用在方法上。</p><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>参照上部分，在工程中new-&gt;Module-&gt;Java Library，新建一个Java Library Module， 在该Module下创建一个文件ProcessorTest.java。在该Module下的build.gradle的dependencies中添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 自动为processor注册</span><br><span class="line">implementation &apos;com.google.auto.service:auto-service:1.0-rc2&apos;</span><br><span class="line">// 该Module依赖上部分建立的annotation Module</span><br><span class="line">implementation project(&apos;:annotation&apos;)</span><br></pre></td></tr></table></figure><p>com.google.auto.service:auto-service:1.0-rc2依赖的作用是为注解处理器自动注册，它会生成META-INF文件夹。</p><p>注解处理器ProcessorTest的定义如下，其中@AutoService(Processor.class)就是build.gradle中加的依赖帮助其自动注册。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class) // 自动为ProcessorTest注册，生成META-INF文件</span><br><span class="line">public class ProcessorTest extends AbstractProcessor&#123;</span><br></pre></td></tr></table></figure><p>注解处理器ProcessorTest主要包含以下几个部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">    super.init(processingEnvironment);</span><br><span class="line"></span><br><span class="line">    mMessager = processingEnvironment.getMessager();</span><br><span class="line">    mFiler = processingEnvironment.getFiler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init方法是注解处理器会自动调用的初始化方法，其中mFiler是用来生成java源文件的工具，mMessager是用来打印日志的，它们的具体使用会在后面介绍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">    Set&lt;String&gt; supportAnnotationTypes = new HashSet&lt;&gt;();</span><br><span class="line">    supportAnnotationTypes.add(AnnotationTest.class.getCanonicalName());</span><br><span class="line">    return supportAnnotationTypes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getSupportedAnnotationTypes()方法返回该注解处理器支持的注解类型，这里返回的就是我们之前声明的新的注解类型@AnnotationTest。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public SourceVersion getSupportedSourceVersion() &#123;</span><br><span class="line">    return SourceVersion.latestSupported();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getSupportedSourceVersion()方法一般就按照上述实现就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">// 打印日志</span><br><span class="line">    mMessager.printMessage(Diagnostic.Kind.NOTE, &quot;process start&quot;);</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; collectInfos = new HashMap&lt;&gt;();</span><br><span class="line">    for (TypeElement annotation: annotations)&#123;</span><br><span class="line">        Set&lt;? extends Element&gt; elements = roundEnvironment.getElementsAnnotatedWith(annotation);</span><br><span class="line">        for (Element element: elements)&#123;</span><br><span class="line">        // 检查element是否符合我们定义的规范</span><br><span class="line">            if (!checkValid(element))&#123;</span><br><span class="line">                mMessager.printMessage(Diagnostic.Kind.NOTE, &quot;checkValid not pass&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                ExecutableElement executableElement = (ExecutableElement) element;</span><br><span class="line">                // 获取被注解的方法所在的类</span><br><span class="line">                TypeElement typeElement = (TypeElement) executableElement.getEnclosingElement();</span><br><span class="line">                // 获取类的全名，包括包名</span><br><span class="line">                String classFullName = typeElement.getQualifiedName().toString();</span><br><span class="line">                // 被注解的方法的名字</span><br><span class="line">                String methodName = executableElement.getSimpleName().toString();</span><br><span class="line">                List&lt;String&gt; methods = collectInfos.get(classFullName);</span><br><span class="line">                if (methods == null)&#123;</span><br><span class="line">                    methods = new ArrayList&lt;&gt;();</span><br><span class="line">                    collectInfos.put(classFullName, methods);</span><br><span class="line">                &#125;</span><br><span class="line">                methods.add(methodName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry: collectInfos.entrySet())&#123;</span><br><span class="line">        mMessager.printMessage(Diagnostic.Kind.NOTE, entry.getKey());</span><br><span class="line">        // 生成java源文件</span><br><span class="line">        createJavaFile(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>process方法是我们的主要逻辑处理的地方，主要逻辑就是收集所有有@AnnotationTest注解的方法以及其所在的类信息，然后根据每个类信息，生成一个新的类文件，并在新的类文件的特定方法中调用所有关联的注解方法。生成java源文件将使用Filer对象，具体如何使用请下载demo看源代码。</p><p><strong>注：</strong> </p><p>1、当你点击buid project时，注解处理器将会执行，而Messager对象打印出来的日志信息可以在Gradle Console窗口中看到。</p><p>2、如果你在该Module中使用中文注解，因为该Module为java library，可能会报GBK编码错误，解决办法是在该Module的build.gradle中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//指定编译的编码</span><br><span class="line">tasks.withType(JavaCompile)&#123;</span><br><span class="line">    options.encoding = &quot;UTF-8&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lib"><a href="#Lib" class="headerlink" title="Lib"></a>Lib</h3><p>在工程中new-&gt;Module-&gt;Android Library ，新建一个Android Library Module，封装接口给调用方使用，具体逻辑请参考demo。</p><p>最终该demo的功能是点击Hello world文字，会依此执行MainActivity中使用@AnnotationTest注解的方法。</p>]]></content>
      
      
      <categories>
          
          <category> 注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> annotation、processor、自动生成java文件 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
